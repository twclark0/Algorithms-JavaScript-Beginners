import { CodeSurferLayout, CodeSurferColumnLayout } from 'code-surfer'
import { nightOwlFull } from 'code-surfer'
import { Head } from 'mdx-deck'
import './index.css'
import { Emoji } from './Emoji.js'
import Img from 'components/Img'
import Footer from 'components/Footer/index.js'

export const themes = [
  nightOwlFull,
  {
    colors: {
      text: '#000',
      background: '#fff',
      primary: '#0af',
      black: '#000'
    },
    fontWeights: {
      heading: 600,
      bold: 600
    },
    text: {
      heading: {
        textTransform: 'uppercase',
        letterSpacing: '0.1em'
      }
    },
    styles: {
      pre: {
        color: 'primary',
        bg: 'black'
      },
      code: {
        color: 'primary'
      }
    }
  }
]

export { nightOwlFull as theme } from 'code-surfer'

<Head>

  <link
    href="https://fonts.googleapis.com/css?family=Montserrat:300,300i,400,400i,500,500i,700"
    rel="stylesheet"
  />
</Head>

### Algorithms in JavaScript for Beginners

> Tyler Clark

---

# :wave: Nice to meet ya

> Full stack software engineer: _@pluralsight_

> Twitter: _@iamtylerwclark_

---

##### Algorithm concepts... kind of scary right?

---

<Img url="./twitter.png" />

---

# Table of Contents

- Recursion
- Big O Notation
- Data Structures
- Common Algorithms

<Footer />

---

# Recursion

- Function that calls itself
- Has a base case escape and recursive case
- No performance benefit over loops

<Footer />

---

<CodeSurferLayout>

```js title="Recursion"
function counter() {
  for (let n = 0; n <= 10; n++) {
    console.log(n)
  }
}

counter() // 0, 1, 2, 3, 4...
```

```js 2:4 title="Recursion"
function counter() {
  for (let n = 0; n <= 10; n++) {
    console.log(n)
  }
}

counter() // 0, 1, 2, 3, 4...
```

```js 7 title="Recursion"
function counter() {
  for (let n = 0; n <= 10; n++) {
    console.log(n)
  }
}

counter() // 0, 1, 2, 3, 4...
```

```js title="Recursion"
function counter(n) {
  console.log(n)
  return counter(n + 1)
}

counter(0) // 0, 1, 2, 3, 4...Infinity
```

```js 3 title="Recursion"
function counter(n) {
  console.log(n)
  return counter(n + 1)
}

counter(0) // 0, 1, 2, 3, 4...Infinity
```

```js 6 title="Recursion"
function counter(n) {
  console.log(n)
  return counter(n + 1)
}

counter(0) // 0, 1, 2, 3, 4...Infinity
```

```js title="Recursion"
function counter(n) {
  console.log(n)
  if (n === 10) return
  return counter(n + 1)
}

counter(0) // 0, 1, 2, 3, 4...10
```

</CodeSurferLayout>

---

# Recursion - That's it

- Function that calls itself

<Footer />

---

# Big O Notation

- How runtime increases as the size of the input increases
- Is the worse case scenario of finding an answer
- "O" syntax

<Footer />

---

<CodeSurferLayout>

```js title="Single lookup"
const a = [1, 2, 3, 4]
```

```js title="Single lookup"
const a = [1, 2, 3, 4]

function findLastValue(a) {
  return a[a.length]
}

console.log(findLastValue(a))
```

</CodeSurferLayout>

---

# O(1)

<Footer />

---

<CodeSurferLayout>

```js title="Single loop"
const a = [1, 2, 3, 4]

function find(a) {
  for (let i = 0; i < a.length; i++) {
    if (a[i] === 4) {
      return 'yes!'
    }
  }
}
```

```js 4 title="Single loop"
const a = [1, 2, 3, 4]

function find(a) {
  for (let i = 0; i < a.length; i++) {
    if (a[i] === 4) {
      return 'yes!'
    }
  }
}
```

</CodeSurferLayout>

---

# O(n)

<Footer />

---

<CodeSurferLayout>

```js title="Nested loop"
const a = [1, 2, 3, 4]

function sort(a) {
  for (let i = 0; i < a.length; i++) {
    // do something
    for (let p = 0; p < a.length; p++) {
      // do something
    }
  }
}
```

</CodeSurferLayout>

---

# O(n^2)

<Footer />

---

<CodeSurferLayout>

```js title="Cutting in half"
const items = [1, 2, 3, 5, 7, 10, 60, 100]

while (low <= high) {
  let low = 0
  let high = list.length
  let mid = Math.floor((low + high) / 2)

  // do stuff with the halved dataset
}
```

</CodeSurferLayout>

---

# O(log n)

#### Log time

<Footer />

---

# Logs

- Always means log-two (2^3)
- At 1000 items only ~10 iterations
- At million, only ~20 iterations

<Footer />

---

### Other Big O Notations

- O (n log n) (Not to bad)
- O(2 \* n) (Really really slow)
- O (n!) (Extremely slow)

<Footer />

---

### Big O Notation recap

- How quickly the runtime grows as input grows
- Big "O" syntax

<Footer />

---

# Data structures

- Objects
- Arrays
- Maps
- Sets

<Footer />

---

# Data structures

- Linked Lists
- Stacks & Queues
- Trees & Graphs
- Heaps
- Vectors / ArrayLists
- Hash Tables

<Footer />

---

# Linked Lists

- Stores multiple values in a linear fashion
- Each node contains value and link to next node

<Footer />

---

<CodeSurferLayout>

```js title="Linked lists"
function LinkedListNode(data) {
  this.data = data
  this.next = null
}
```

```js 2:3 title="Linked lists"
function LinkedListNode(data) {
  this.data = data
  this.next = null
}
```

```js title="Linked lists"
function LinkedListNode(data) {
  this.data = data
  this.next = null
}

const head = new LinkedListNode(1)
```

```js title="Linked lists"
function LinkedListNode(data) {
  this.data = data
  this.next = null
}

const head = new LinkedListNode(1)
head.next = new LinkedListNode(2)
```

```js 1:7 title="Linked lists"
function LinkedListNode(data) {
  this.data = data
  this.next = null
}

const head = new LinkedListNode(1)
head.next = new LinkedListNode(2)
```

```js title="Linked lists"
head = {
  data: 1,
  next: {
    data: 2,
    next: null
  }
}
```

</CodeSurferLayout>

---

# Stacks

- Last-in, first-out
- Think call stacks, recursive functions

<Footer />

---

<CodeSurferLayout>

```js  title="Stacks"
const stack = [1]
```

```js title="Stacks"
const stack = [1, 2]
```

```js  title="Stacks"
const stack = [1, 2, 3]
```

```js title="Stacks"
const stack = [1, 2]
```

```js title="Stacks"
const stack = [1]
```

</CodeSurferLayout>

---

# Stacks

- pop(): Remove top item from stack
- push(i): Add an item to top of stack
- peek(): Return the top of stack
- isEmpty(): Returns true if stack is empty

<Footer />

---

<CodeSurferLayout>

```js  title="Stacks"
function CreateStack() {
  this.stack = []
  this.pop = x => {}
  this.push = x => {}
  this.peek = () => {}
  this.isEmpty = () => {}
}

const myStack = new CreateStack()
```

</CodeSurferLayout>

---

# Queues

- First-in, first-out
- Removed in the order they are added

<Footer />

---

<CodeSurferLayout>

```js  title="Queues"
const queue = [1]
```

```js title="Queues"
const queue = [1, 2]
```

```js  title="Queues"
const queue = [1, 2, 3]
```

```js title="Queues"
const queue = [2, 3]
```

```js title="Queues"
const queue = [3]
```

</CodeSurferLayout>

---

# Queues

- add(): Add an item to end of list
- remove(): remove the first item in the list
- peek(): return the top of the queue
- isEmpty(): return true if queue is empty

<Footer />

---

<CodeSurferLayout>

```js  title="Queues"
function CreateQueue() {
  this.queue = []
  this.add = x => {}
  this.remove = x => {}
  this.peek = () => {}
  this.isEmpty = () => {}
}

const queue = new CreateQueue()
```

</CodeSurferLayout>

---

# Trees & Graphs

- Sometimes the most difficult to understand
- Not linear
- Composed as nodes with zero or more child nodes
- Trees have a root node, cannot have cycles

<Footer />

---

### Parent > Child

<Footer />

---

<CodeSurferLayout>

```js title="Trees"
function Node(value) {
  this.value = value
  this.children = []
}
```

```js title="Trees"
function Node(value) {
  this.value = value
  this.children = []
}

const terry = new Node('terry')
```

```js title="Trees"
function Node(value) {
  this.value = value
  this.children = []
}

const terry = new Node('terry')
const katie = new Node('katie')
```

```js title="Trees"
function Node(value) {
  this.value = value
  this.children = []
}

const terry = new Node('terry')
const katie = new Node('katie')

terry.children.push(katie)
```

```js 1:9 title="Trees"
{
  value: 'terry',
  children: [
    {
      value: 'katie',
      children: []
    }
  ]
}
```

</CodeSurferLayout>

---

# Graphs

- All trees are graphs but not all graphs are trees
- Can be cyclical

<Footer />

---

### Friends

<Footer />

---

<CodeSurferLayout>

```js 1:9 title="Trees"
{
value: 'terry',
children: [
  {
    value: 'katie',
    children: []
  }
]
}
```

```js 1:9 title="Graphs (Friends)"
{
  terry:  [ {name: 'katie' } ],
  katie: [ {name: 'terry'} ],
  hannah: [ {name: 'terry'} ]
}
```

</CodeSurferLayout>

---

# Common Algorithms

- Selection Sort
- Bubble Sort
- Quicksort
- Binary Search

---

# Selection Sort

- First loops over every item in list
- Calls a function that loops over each item and returns the largest
- Pushing values into a new list
- Remove values from old list

<Footer />

---

<CodeSurferLayout>

```js title="Selection sort"
const itemsToSort = [3, 2, 4, 1, 6]

function selectionSort(list) {
  let newList = []
  let lrgItem
  while (list.length) {
    lrgItem = findLargestValue(list)
    newList.push(list[lrgItem])
    list.splice(lrgItem, 1)
  }
  return newList
}
```

```js 6 title="Selection sort"
const itemsToSort = [3, 2, 4, 1, 6]

function selectionSort(list) {
  let newList = []
  let lrgItem
  while (list.length) {
    lrgItem = findLargestValue(list)
    newList.push(list[lrgItem])
    list.splice(lrgItem, 1)
  }
  return newList
}
```

```js 7 title="Selection sort"
const itemsToSort = [3, 2, 4, 1, 6]

function selectionSort(list) {
  let newList = []
  let lrgItem
  while (list.length) {
    lrgItem = findLargestValue(list)
    newList.push(list[lrgItem])
    list.splice(lrgItem, 1)
  }
  return newList
}
```

```js title="Selection sort"
function findLargestValue(list) {
  let lrg = list[0]
  let indexOfLarge = 0
  for (let i = 1; i <= list.length; i++) {
    if (lrg < list[i]) {
      lrg = list[i]
      indexOfLarge = i
    }
  }
  return indexOfLarge
}
```

```js 4 title="Selection sort"
function findLargestValue(list) {
  let lrg = list[0]
  let indexOfLarge = 0
  for (let i = 1; i <= list.length; i++) {
    if (lrg < list[i]) {
      lrg = list[i]
      indexOfLarge = i
    }
  }
  return indexOfLarge
}
```

```js 1:26 title="Selection sort"
const itemsToSort = [3, 2, 4, 1, 6]

function findLargestValue(list) {
  let lrg = list[0]
  let indexOfLarge = 0
  for (let i = 1; i <= list.length; i++) {
    if (lrg < list[i]) {
      lrg = list[i]
      indexOfLarge = i
    }
  }
  return indexOfLarge
}

function selectionSort(list) {
  let newList = []
  let lrgItem
  while (list.length) {
    lrgItem = findLargestValue(list)
    newList.push(list[lrgItem])
    list.splice(lrgItem, 1)
  }
  return newList
}

selectionSort(itemsToSort)
```

</CodeSurferLayout>

---

# O(n^2)

---

# Bubble Sort

- Steps through each item and compares adjacent items
- Swaps if they are in the wrong order

---

<CodeSurferLayout>

```js title="Bubble Sort"
const items = [1, 20, 3, 2, 7]

function bubbleSort(list) {
  for (let i = 0; i < list.length; i++) {
    for (let j = 0; j < list.length; j++) {
      if (list[j - 1] > list[j]) {
        swap(list, j - 1, j)
      }
    }
  }
  return list
}
```

</CodeSurferLayout>

---

# O(n^2)

---

# Quicksort

- Utilizes a "pivot" and recursion
- Partion lists with each recursive call
- One of the most efficient sorting algorithms
- Best case is O(n log n)
- Worse is O(n^2)

---

# Binary Search

- Takes a sorted list
- Jumps to middle, determines to high or low
- Repeats until it finds the answer

<Footer />

---

<CodeSurferLayout>

```js title="Binary Search"
const items = [1, 2, 3, 5, 7, 10, 60, 100]
```

```js title="Binary Search"
const items = [1, 2, 3, 5, 7, 10, 60, 100]

let low = 0
let high = list.length
let mid = Math.floor((low + high) / 2)
```

```js 4:6 title="Binary Search"
const items = [1, 2, 3, 5, 7, 10, 60, 100]

function search(list, item) {
  let low = 0
  let high = list.length
  while (low <= high) {
    let mid = Math.floor((low + high) / 2)
    let guess = list[mid]
    if (guess === item) return true
    if (guess > item) high = mid - 1
    else low = mid + 1
  }
  return null
}
```

```js 7 title="Binary Search"
const items = [1, 2, 3, 5, 7, 10, 60, 100]

function search(list, item) {
  let low = 0
  let high = list.length
  while (low <= high) {
    let mid = Math.floor((low + high) / 2)
    let guess = list[mid]
    if (guess === item) return true
    if (guess > item) high = mid - 1
    else low = mid + 1
  }
  return null
}
```

```js 8 title="Binary Search"
const items = [1, 2, 3, 5, 7, 10, 60, 100]

function search(list, item) {
  let low = 0
  let high = list.length
  while (low <= high) {
    let mid = Math.floor((low + high) / 2)
    let guess = list[mid]
    if (guess === item) return true
    if (guess > item) high = mid - 1
    else low = mid + 1
  }
  return null
}
```

```js 9 title="Binary Search"
const items = [1, 2, 3, 5, 7, 10, 60, 100]

function search(list, item) {
  let low = 0
  let high = list.length
  while (low <= high) {
    let mid = Math.floor((low + high) / 2)
    let guess = list[mid]
    if (guess === item) return true
    if (guess > item) high = mid - 1
    else low = mid + 1
  }
  return null
}
```

```js 10 title="Binary Search"
const items = [1, 2, 3, 5, 7, 10, 60, 100]

function search(list, item) {
  let low = 0
  let high = list.length
  while (low <= high) {
    let mid = Math.floor((low + high) / 2)
    let guess = list[mid]
    if (guess === item) return true
    if (guess > item) high = mid - 1
    else low = mid + 1
  }
  return null
}
```

```js 11 title="Binary Search"
const items = [1, 2, 3, 5, 7, 10, 60, 100]

function search(list, item) {
  let low = 0
  let high = list.length
  while (low <= high) {
    let mid = Math.floor((low + high) / 2)
    let guess = list[mid]
    if (guess === item) return true
    if (guess > item) high = mid - 1
    else low = mid + 1
  }
  return null
}
```

</CodeSurferLayout>

---

# O(log n)

#### Log time

<Footer />

---

> Everybody in this country should learn to program a computer, because it teaches you how to think

_-Steve Jobs_

<Footer />

---

# Other references

- Cracking the coding interview
- The Imposter's Handbook
- Egghead, Pluralsight, Frontend Masters courses

<Footer />

---

### Thanks!

<Footer />

```

```
